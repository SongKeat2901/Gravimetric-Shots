/*
  AcaiaArduinoBLE.cpp - Library for connecting to
  an Acaia Scale using NimBLE library (ESP32 native).
  
  Refactored from ArduinoBLE to NimBLE for better WiFi+BLE coexistence.
  Based on original by Tate Mazer, December 13, 2023.
  NimBLE port: October 2025.
*/

#include "Arduino.h"
#include "AcaiaArduinoBLE.h"
#include "NimBLEDevice.h"

#define HEADER1 0xef
#define HEADER2 0xdd

byte IDENTIFY[20] = {0xef, 0xdd, 0x0b, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x9a, 0x6d};
byte HEARTBEAT[7] = {0xef, 0xdd, 0x00, 0x02, 0x00, 0x02, 0x00};
byte NOTIFICATION_REQUEST[14] = {0xef, 0xdd, 0x0c, 0x09, 0x00, 0x01, 0x01, 0x02, 0x02, 0x05, 0x03, 0x04, 0x15, 0x06};
byte START_TIMER[7] = {0xef, 0xdd, 0x0d, 0x00, 0x00, 0x00, 0x00};
byte STOP_TIMER[7] = {0xef, 0xdd, 0x0d, 0x00, 0x02, 0x00, 0x02};
byte RESET_TIMER[7] = {0xef, 0xdd, 0x0d, 0x00, 0x01, 0x00, 0x01};
byte TARE_ACAIA[6] = {0xef, 0xdd, 0x04, 0x00, 0x00, 0x00};
byte TARE_GENERIC[1] = {0x54};

int count = 0;

// LVGL timer handler (external)
const int lvUpdateInterval = 16;
unsigned long lastLvUpdate = 0;
extern void LVGLTimerHandlerRoutine();

// Static instance pointer for callbacks
AcaiaArduinoBLE* AcaiaArduinoBLE::_instance = nullptr;

// Scan callback class - detects Acaia scales
class AcaiaScanCallbacks : public NimBLEAdvertisedDeviceCallbacks {
    void onResult(NimBLEAdvertisedDevice* advertisedDevice) {
        if (AcaiaArduinoBLE::_instance) {
            String name = String(advertisedDevice->getName().c_str());
            if (AcaiaArduinoBLE::_instance->isScaleName(name)) {
                Serial.print("Scale found: ");
                Serial.println(name);
                NimBLEDevice::getScan()->stop();
                // Store device for connection
                AcaiaArduinoBLE::_instance->_pAdvDevice = advertisedDevice;
            }
        }
    }
};

// Client callbacks - handle connection events
class AcaiaClientCallbacks : public NimBLEClientCallbacks {
    void onConnect(NimBLEClient* pClient) {
        Serial.println("NimBLE Client connected");
    }
    
    void onDisconnect(NimBLEClient* pClient) {
        Serial.println("NimBLE Client disconnected");
        if (AcaiaArduinoBLE::_instance) {
            AcaiaArduinoBLE::_instance->_connected = false;
            // CRITICAL: Transition state machine to FAILED on disconnect
            // This prevents continued execution with invalid pointers
            AcaiaArduinoBLE::_instance->transitionTo(CONN_FAILED, 0);
            // Clear characteristic pointers to prevent dangling references
            AcaiaArduinoBLE::_instance->_pReadChar = nullptr;
            AcaiaArduinoBLE::_instance->_pWriteChar = nullptr;
            AcaiaArduinoBLE::_instance->_pService = nullptr;
        }
    }
};

static AcaiaScanCallbacks scanCallbacks;
static AcaiaClientCallbacks clientCallbacks;

// Constructor
AcaiaArduinoBLE::AcaiaArduinoBLE()
{
    _instance = this;
    _currentWeight = 999;
    _connected = false;
    _packetPeriod = 0;

    // Initialize state machine
    _connState = CONN_IDLE;
    _connStateStart = 0;
    _connTimeout = 0;
    _mac = "";
    _lastDisconnect = 0;
    
    // Initialize NimBLE pointers
    _pClient = nullptr;
    _pService = nullptr;
    _pWriteChar = nullptr;
    _pReadChar = nullptr;
    _pAdvDevice = nullptr;
    _pScan = nullptr;
}

bool AcaiaArduinoBLE::init(String mac)
{
    // Don't restart if already connecting or connected
    if (_connState != CONN_IDLE && _connState != CONN_FAILED)
    {
        // Silently reject - this is called frequently from loop
        return false;
    }

    Serial.print("AcaiaArduinoBLE Library v");
    Serial.print(LIBRARY_VERSION);
    Serial.println(" - Starting non-blocking connection...");

    _mac = mac;
    _lastPacket = 0;
    _connected = false;
    _pAdvDevice = nullptr;

    // Get or create scan object
    _pScan = NimBLEDevice::getScan();
    if (!_pScan) {
        Serial.println("Failed to get scan object!");
        return false;
    }

    // Configure scan
    _pScan->setAdvertisedDeviceCallbacks(&scanCallbacks, false);
    _pScan->setActiveScan(true);
    _pScan->setInterval(100);
    _pScan->setWindow(99);

    // Start scanning
    Serial.println("BLE scan started (non-blocking)");
    _pScan->start(0, nullptr, false); // 0 = scan forever until stopped
    
    transitionTo(CONN_SCANNING, 10000);  // 10 second scan timeout
    return true;
}

bool AcaiaArduinoBLE::tare()
{
    if (!_connected || !_pWriteChar)
    {
        Serial.println("tare failed: not connected");
        return false;
    }

    if (_pWriteChar->writeValue((_type == GENERIC ? TARE_GENERIC : TARE_ACAIA), 
                                  (_type == GENERIC ? 1 : 6), true))
    {
        Serial.println("tare write successful");
        return true;
    }
    else
    {
        _connected = false;
        Serial.println("tare write failed");
        return false;
    }
}

bool AcaiaArduinoBLE::startTimer()
{
    if (!_connected || !_pWriteChar)
    {
        Serial.println("start timer failed: not connected");
        return false;
    }

    if (_pWriteChar->writeValue(START_TIMER, 7, true))
    {
        Serial.println("start timer write successful");
        return true;
    }
    else
    {
        _connected = false;
        Serial.println("start timer write failed");
        return false;
    }
}

bool AcaiaArduinoBLE::stopTimer()
{
    if (!_connected || !_pWriteChar)
    {
        Serial.println("stop timer failed: not connected");
        return false;
    }

    if (_pWriteChar->writeValue(STOP_TIMER, 7, true))
    {
        Serial.println("stop timer write successful");
        return true;
    }
    else
    {
        _connected = false;
        Serial.println("stop timer write failed");
        return false;
    }
}

bool AcaiaArduinoBLE::resetTimer()
{
    if (!_connected || !_pWriteChar)
    {
        Serial.println("reset timer failed: not connected");
        return false;
    }

    if (_pWriteChar->writeValue(RESET_TIMER, 7, true))
    {
        Serial.println("reset timer write successful");
        return true;
    }
    else
    {
        _connected = false;
        Serial.println("reset timer write failed");
        return false;
    }
}

bool AcaiaArduinoBLE::heartbeat()
{
    if (!_connected || !_pWriteChar)
    {
        Serial.println("heartbeat failed: not connected");
        return false;
    }

    if (_pWriteChar->writeValue(HEARTBEAT, 7, true))
    {
        _lastHeartBeat = millis();
        return true;
    }
    else
    {
        _connected = false;
        return false;
    }
}

float AcaiaArduinoBLE::getWeight()
{
    return _currentWeight;
}

bool AcaiaArduinoBLE::heartbeatRequired()
{
    if (_type == OLD || _type == NEW)
    {
        return (millis() - _lastHeartBeat) > HEARTBEAT_PERIOD_MS;
    }
    else
    {
        return false;
    }
}

bool AcaiaArduinoBLE::isConnected()
{
    return _connected;
}

int AcaiaArduinoBLE::batteryValue()
{
    return _currentBattery;
}

// Notification callback - called when scale sends weight data
void AcaiaArduinoBLE::notifyCallback(NimBLERemoteCharacteristic* pRemoteCharacteristic,
                                      uint8_t* pData, size_t length, bool isNotify)
{
    if (_instance) {
        _instance->handleNotification(pData, length);
    }
}

void AcaiaArduinoBLE::handleNotification(uint8_t* pData, size_t length)
{
    // Parse weight data based on scale type
    if (NEW == _type && length >= 13 && pData[2] == 0x0C && pData[4] == 0x05)
    {
        // New Acaia (Lunar 2021, Pyxis)
        _currentWeight = (((pData[6] & 0xff) << 8) + (pData[5] & 0xff)) / pow(10, pData[9]) * ((pData[10] & 0x02) ? -1 : 1);
        
        if (_lastPacket)
        {
            _packetPeriod = millis() - _lastPacket;
        }
        _lastPacket = millis();
    }
    else if (OLD == _type && length >= 10)
    {
        // Old Acaia (Lunar pre-2021)
        _currentWeight = (((pData[3] & 0xff) << 8) + (pData[2] & 0xff)) / pow(10, pData[6]) * ((pData[7] & 0x02) ? -1 : 1);
        
        if (_lastPacket)
        {
            _packetPeriod = millis() - _lastPacket;
        }
        _lastPacket = millis();
    }
    else if (GENERIC == _type && length >= 13)
    {
        // Generic scales (Felicita Arc)
        _currentWeight = (pData[2] == 0x2B ? 1 : -1) * 
                        ((pData[3] - 0x30) * 1000 + (pData[4] - 0x30) * 100 + 
                         (pData[5] - 0x30) * 10 + (pData[6] - 0x30) * 1 + 
                         (pData[7] - 0x30) * 0.1 + (pData[8] - 0x30) * 0.01);
        
        if (_lastPacket)
        {
            _packetPeriod = millis() - _lastPacket;
        }
        _lastPacket = millis();
    }
}

bool AcaiaArduinoBLE::newWeightAvailable()
{
    // Check for connection timeout
    if (_lastPacket && millis() - _lastPacket > MAX_PACKET_PERIOD_MS)
    {
        Serial.println("Connection timeout - no packets received!");
        _connected = false;
        _connState = CONN_FAILED;
        _lastPacket = 0;
        return false;
    }

    // Weight updates come via notification callback
    // Just check if we received data recently
    return (_lastPacket > 0);
}

bool AcaiaArduinoBLE::isScaleName(String name)
{
    String nameShort = name.substring(0, 5);
    return nameShort == "CINCO" || nameShort == "ACAIA" || nameShort == "PYXIS" || 
           nameShort == "LUNAR" || nameShort == "PROCH" || nameShort == "FELIC";
}

// State machine helpers
void AcaiaArduinoBLE::transitionTo(ConnectionState newState, unsigned long timeout)
{
    _connState = newState;
    _connStateStart = millis();
    _connTimeout = timeout;
}

bool AcaiaArduinoBLE::isConnecting()
{
    return _connState != CONN_IDLE && _connState != CONN_CONNECTED && _connState != CONN_FAILED;
}

ConnectionState AcaiaArduinoBLE::getConnectionState()
{
    return _connState;
}

const char* AcaiaArduinoBLE::getStateString()
{
    switch (_connState) {
        case CONN_IDLE:         return "Idle";
        case CONN_SCANNING:     return "Scanning";
        case CONN_CONNECTING:   return "Connecting";
        case CONN_DISCOVERING:  return "Discovering";
        case CONN_SUBSCRIBING:  return "Subscribing";
        case CONN_IDENTIFYING:  return "Identifying";
        case CONN_BATTERY:      return "Battery";
        case CONN_NOTIFICATIONS: return "Notifications";
        case CONN_CONNECTED:    return "Connected";
        case CONN_FAILED:       return "Failed";
        default:                return "Unknown";
    }
}

// State machine handlers - NimBLE implementation

void AcaiaArduinoBLE::stateScanning()
{
    // Check if scan callback found a device
    if (_pAdvDevice)
    {
        _pScan->stop();
        transitionTo(CONN_CONNECTING, 5000);  // 5s connect timeout
    }
    // Timeout handled by update()
}

void AcaiaArduinoBLE::stateConnecting()
{
    Serial.println("Connecting ...");
    
    // Create or get client
    if (!_pClient) {
        _pClient = NimBLEDevice::createClient();
        if (!_pClient) {
            Serial.println("Failed to create client!");
            transitionTo(CONN_FAILED, 0);
            return;
        }
        _pClient->setClientCallbacks(&clientCallbacks, false);
        _pClient->setConnectionParams(12, 12, 0, 150);
        _pClient->setConnectTimeout(5);
    }
    
    // Connect to device
    if (_pClient->connect(_pAdvDevice))
    {
        Serial.println("Connected");
        transitionTo(CONN_DISCOVERING, 5000);  // 5s discover timeout
    }
    else
    {
        Serial.println("Connection failed!");
        _pAdvDevice = nullptr;
        transitionTo(CONN_FAILED, 0);
    }
}

void AcaiaArduinoBLE::stateDiscovering()
{
    Serial.println("Discovering services ...");
    
    // Reset watchdog (can take time)
    esp_task_wdt_reset();
    
    // Try to get services (NimBLE auto-discovers on connect)
    // Just need to find the right characteristic UUIDs
    
    transitionTo(CONN_SUBSCRIBING, 5000);  // 5s subscribe timeout
}

void AcaiaArduinoBLE::stateSubscribing()
{
    // Reset watchdog before characteristic operations
    esp_task_wdt_reset();

    Serial.println("Finding characteristics ...");

    // CRITICAL: Check if still connected before accessing characteristics
    // Client can disconnect during previous state transitions
    if (!_pClient || !_pClient->isConnected()) {
        Serial.println("Client disconnected during subscribing");
        transitionTo(CONN_FAILED, 0);
        return;
    }

    // Try OLD version first
    _pService = _pClient->getService(NimBLEUUID("00001820-0000-1000-8000-00805f9b34fb"));
    if (_pService) {
        // CRITICAL: Must retrieve characteristics from the service first
        std::vector<NimBLERemoteCharacteristic*>* pChars = _pService->getCharacteristics(true);

        // Check connection after getCharacteristics (can trigger disconnect)
        if (!_pClient->isConnected()) {
            Serial.println("Client disconnected during OLD characteristic discovery");
            transitionTo(CONN_FAILED, 0);
            return;
        }

        NimBLERemoteCharacteristic* tempReadChar = _pService->getCharacteristic(NimBLEUUID(READ_CHAR_OLD_VERSION));

        // CRITICAL: Check connection again before committing pointers
        if (!_pClient->isConnected()) {
            Serial.println("Client disconnected after getting OLD read characteristic");
            transitionTo(CONN_FAILED, 0);
            return;
        }

        if (tempReadChar && tempReadChar->canNotify()) {
            Serial.println("Old version Acaia Detected");
            _type = OLD;
            _pReadChar = tempReadChar;
            _pWriteChar = _pService->getCharacteristic(NimBLEUUID(WRITE_CHAR_OLD_VERSION));
        }
    }

    // Try NEW version
    if (!_pReadChar) {
        _pService = _pClient->getService(NimBLEUUID("49535343-fe7d-4ae5-8fa9-9fafd205e455"));
        if (_pService) {
            // CRITICAL: Must retrieve characteristics from the service first
            std::vector<NimBLERemoteCharacteristic*>* pChars = _pService->getCharacteristics(true);

            // Check connection after getCharacteristics (can trigger disconnect)
            if (!_pClient->isConnected()) {
                Serial.println("Client disconnected during NEW characteristic discovery");
                transitionTo(CONN_FAILED, 0);
                return;
            }

            NimBLERemoteCharacteristic* tempReadChar = _pService->getCharacteristic(NimBLEUUID(READ_CHAR_NEW_VERSION));

            // CRITICAL: Check connection again before committing pointers
            // Disconnect can happen between getCharacteristics and getCharacteristic
            if (!_pClient->isConnected()) {
                Serial.println("Client disconnected after getting read characteristic");
                transitionTo(CONN_FAILED, 0);
                return;
            }

            if (tempReadChar && tempReadChar->canNotify()) {
                Serial.println("New version Acaia Detected");
                _type = NEW;
                _pReadChar = tempReadChar;
                _pWriteChar = _pService->getCharacteristic(NimBLEUUID(WRITE_CHAR_NEW_VERSION));
            }
        }
    }

    // Try GENERIC
    if (!_pReadChar) {
        _pService = _pClient->getService(NimBLEUUID("0000ffe0-0000-1000-8000-00805f9b34fb"));
        if (_pService) {
            // CRITICAL: Must retrieve characteristics from the service first
            std::vector<NimBLERemoteCharacteristic*>* pChars = _pService->getCharacteristics(true);

            // Check connection after getCharacteristics (can trigger disconnect)
            if (!_pClient->isConnected()) {
                Serial.println("Client disconnected during GENERIC characteristic discovery");
                transitionTo(CONN_FAILED, 0);
                return;
            }

            NimBLERemoteCharacteristic* tempReadChar = _pService->getCharacteristic(NimBLEUUID(READ_CHAR_GENERIC));

            // CRITICAL: Check connection again before committing pointers
            if (!_pClient->isConnected()) {
                Serial.println("Client disconnected after getting GENERIC read characteristic");
                transitionTo(CONN_FAILED, 0);
                return;
            }

            if (tempReadChar && tempReadChar->canNotify()) {
                Serial.println("Generic Scale Detected");
                _type = GENERIC;
                _pReadChar = tempReadChar;
                _pWriteChar = _pService->getCharacteristic(NimBLEUUID(WRITE_CHAR_GENERIC));
            }
        }
    }

    if (!_pReadChar || !_pWriteChar) {
        Serial.println("Unable to determine scale type or find characteristics");
        _pClient->disconnect();
        transitionTo(CONN_FAILED, 0);
        return;
    }

    // CRITICAL: Verify still connected before subscribing
    // Client can disconnect during characteristic discovery
    if (!_pClient->isConnected()) {
        Serial.println("Client disconnected before subscription");
        transitionTo(CONN_FAILED, 0);
        return;
    }

    // Subscribe to notifications
    if (!_pReadChar->subscribe(true, notifyCallback)) {
        Serial.println("Subscription failed");
        transitionTo(CONN_FAILED, 0);
        return;
    }
    
    Serial.println("Subscribed to notifications");
    transitionTo(CONN_IDENTIFYING, 5000);  // 5s identify timeout
}

void AcaiaArduinoBLE::stateIdentifying()
{
    Serial.println("Sending identify ...");
    
    if (!_pWriteChar->writeValue(IDENTIFY, 20, true)) {
        Serial.println("Identify write failed");
        transitionTo(CONN_FAILED, 0);
        return;
    }
    
    Serial.println("Identify sent");
    transitionTo(CONN_BATTERY, 2000);  // 2s battery timeout
}

void AcaiaArduinoBLE::stateBattery()
{
    Serial.println("Requesting battery (skipping for now) ...");
    // Battery request implementation can be added later
    transitionTo(CONN_NOTIFICATIONS, 2000);
}

void AcaiaArduinoBLE::stateNotifications()
{
    Serial.println("Enabling weight notifications ...");
    
    if (!_pWriteChar->writeValue(NOTIFICATION_REQUEST, 14, true)) {
        Serial.println("Notification request write failed");
        transitionTo(CONN_FAILED, 0);
        return;
    }
    
    Serial.println("Weight notifications enabled");
    _connected = true;
    _lastHeartBeat = millis();
    _lastPacket = 0;  // Reset packet timer
    transitionTo(CONN_CONNECTED, 0);
}

// Main state machine update - call from loop()
bool AcaiaArduinoBLE::update()
{
    // Always reset watchdog
    esp_task_wdt_reset();

    // LVGL updates removed - handled by main loop on Core 1
    // With FreeRTOS task architecture, BLE runs on Core 0, UI on Core 1
    // LVGL is NOT thread-safe - only main loop should call lv_timer_handler()
    // unsigned long currentMillis = millis();
    // if (currentMillis - lastLvUpdate >= lvUpdateInterval)
    // {
    //     lastLvUpdate = currentMillis;
    //     LVGLTimerHandlerRoutine();
    // }

    // Check for state timeout
    if (_connState != CONN_IDLE && _connState != CONN_CONNECTED && _connState != CONN_FAILED)
    {
        if (millis() - _connStateStart > _connTimeout)
        {
            Serial.print("State timeout: ");
            Serial.println(getStateString());

            if (_pScan && _pScan->isScanning()) {
                _pScan->stop();
            }
            if (_pClient && _pClient->isConnected()) {
                _pClient->disconnect();
            }
            transitionTo(CONN_FAILED, 0);
            return false;
        }
    }

    // Execute current state
    switch (_connState)
    {
        case CONN_IDLE:
            return false;

        case CONN_SCANNING:
            stateScanning();
            break;

        case CONN_CONNECTING:
            stateConnecting();
            break;

        case CONN_DISCOVERING:
            stateDiscovering();
            break;

        case CONN_SUBSCRIBING:
            stateSubscribing();
            break;

        case CONN_IDENTIFYING:
            stateIdentifying();
            break;

        case CONN_BATTERY:
            stateBattery();
            break;

        case CONN_NOTIFICATIONS:
            stateNotifications();
            break;

        case CONN_CONNECTED:
            return true;

        case CONN_FAILED:
            Serial.println("Connection failed - cleaning up and restarting scan");

            // Stop any ongoing scan
            if (_pScan && _pScan->isScanning()) {
                _pScan->stop();
            }

            // Disconnect client
            if (_pClient) {
                if (_pClient->isConnected()) {
                    Serial.println("Disconnecting client");
                    _pClient->disconnect();
                }
                NimBLEDevice::deleteClient(_pClient);
                _pClient = nullptr;
            }

            // Clear connection state
            _pService = nullptr;
            _pWriteChar = nullptr;
            _pReadChar = nullptr;
            _pAdvDevice = nullptr;
            _connected = false;
            _lastPacket = 0;
            _packetPeriod = 0;
            _lastHeartBeat = 0;

            // Small delay
            delay(100);

            // Restart scan
            Serial.println("Scan restarted (non-blocking reconnect)");
            _pScan = NimBLEDevice::getScan();
            if (_pScan) {
                _pScan->start(0, nullptr, false);
                transitionTo(CONN_SCANNING, 10000);  // 10s scan timeout
            } else {
                Serial.println("Failed to restart scan");
                transitionTo(CONN_IDLE, 0);
            }
            break;
    }

    return _connState == CONN_CONNECTED;
}

// Battery request helper (optional - can be enhanced later)
bool AcaiaArduinoBLE::requestBatterySync()
{
    // Battery request protocol can be implemented here
    _currentBattery = 0;  // Default unknown
    return true;
}

